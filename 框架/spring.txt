目录：
	》简介
	》spring IoC和DI
	》spring AOP
	》spring的优势
	》spring能做什么
	》spring框架（模块）结构
	》事务
	》IoC 如何实现
	》面试题
	》所运用到的一些设计模式

简介：
	》Spring是负责协调，实现业务对象管理 即：负责不同层面的衔接
	》两大核心：IOC/DI（控制反转/依赖注入），AOP

spring IoC和DI
	》Inverse of Control（控制反转）：这是一种设计思想，将原本程序中手动创建对象的控制权，交由spring框架来管理。
	》Dependency Injection（依赖注入）：将对象依赖属性通过配置设值给该对象

spring AOP:
	定义：
	》Aspect Oriented Program（面向切面编程） 
	》在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。
	》》所谓的核心业务，比如登陆，增加数据，删除数据都叫核心业务
	》》所谓的周边功能，比如性能统计，日志，事务管理等等
	》最后效果是：核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 "编织" 在一起，这就叫AOP
	目的：
	》与业务无关，却为业务模块所共同调用的逻辑或责任封装起来（事务处理、日志管理、权限控制）
	》减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性
	AOP当中的概念：
	》切入点（Pointcut）   	在哪些类，哪些方法上切入（where）
	》通知（Advice）       	在方法执行的什么时候（when:方法前/方法后/方法前后）做什么（what:增强的功能）
	》切面（Aspect）		切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强！
	》织入（Weaving）		把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）
	AOP 编程：（有空看）
	//目标对象
	package service;
	public class ProductService {
		public void doSomeService(){
			System.out.println("doSomeService");
		}
	}
	//拦截对象
	package aspect;
	import org.aspectj.lang.ProceedingJoinPoint;
	public class LoggerAspect {
		public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
			System.out.println("start log:" + joinPoint.getSignature().getName());
			Object object = joinPoint.proceed();
			System.out.println("end log:" + joinPoint.getSignature().getName());
			return object;
		}
	}
	//配置文件
	<bean name="productService" class="service.ProductService" />
	<bean id="loggerAspect" class="aspect.LoggerAspect"/>
    <!-- 配置AOP -->
    <aop:config>
        <!-- where：在哪些地方（包.类.方法）做增加 -->
        <aop:pointcut id="loggerCutpoint"
                      expression="execution(* service.ProductService.*(..)) "/>
        <!-- what:做什么增强 -->
        <aop:aspect id="logAspect" ref="loggerAspect">
            <!-- when:在什么时机（方法前/后/前后） -->
            <aop:around pointcut-ref="loggerCutpoint" method="log"/>
        </aop:aspect>
    </aop:config>
	
spring的优势：
	》1、低侵入、低耦合
	》2、声明式事务管理
	》3、方便集成其他框架（MyBatis Hibernate）
	》4、降低开发难度
	》5、一站式提供了J2EE三层的解决方案
	
spring能做什么：
	》能帮我们根据配置文件创建及组装对象之间的依赖关系
	》面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制
	》非常简单的帮我们管理数据库事务
	》提供了与第三方的数据访问框架无缝集成，并提供一套JDBC访问模块来方便访问数据库
		MyBatis集成：
			1、通过bean配置爱datasource
			<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			2、通过bean配置SqlSession工厂：
			<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
			3、通过bean配置扫描配置文件
			<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		getCurrentSession和openSession的区别
			1.getCurrentSession的方式会在事务结束时自动关闭连接，而openSession则需要手动关闭连接。
			2.采用getCurrentSession创建的session会绑定带当前的线程中去，但openSession则不会。
	》提供了与第三方web框架的无缝集成，并提供了一套springMVC框架方便web层搭建
	》方便的与javaEE（java Mail、任务调度）整合，与更多技术整合（如缓存框架）

spring框架（模块）结构：
	》如图：spring模块结构.PNG
	》Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。
	》Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。
	》AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。
	》Core Container(核心容器)：包含有Beans、Core、Context和SpEL模块。
	》Test模块支持使用JUnit和TestNG对Spring组件进行测试。
	
事务：
	声明式事务：
	1、Spring 的声明式事务管理在底层是建立在 AOP 的基础上。其本质是在方法前后进行拦截，
	然后在目标方法开始之前创建一个事务，在执行这目标方法结束后，根据执行情况提交或进行回滚事务。
	2、声明式事务最大的优点就是不需通过编程的方式而进行管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，
	只需在配置文件中做相关的事务规则声明，便可将事务规则应用到业务逻辑中。
	3、声明式事务不足的地方在于，与编程式事务相比，只能作用到方法级别，无法像编程式事务那样可以作用到代码块级别。
	编程式事务：
	》

IoC 如何实现：
	》1、读取标注或者配置文件
	》2、使用反射的API，基于类名实例化对应的对象实例
	》3、将对象实例，通过构造函数或者 setter，传递给对象
	
所运用到的一些设计模式：
	1.工厂模式，这个很明显，在各种BeanFactory以及ApplicationContext创建中都用到了；
	2.模版模式，这个也很明显，在各种BeanFactory以及ApplicationContext实现中也都用到了；
	3.代理模式，在Aop实现中用到了JDK的动态代理；
	4.单例模式，这个比如在创建bean的时候。
	5.Tomcat中有很多场景都使用到了外观模式，因为Tomcat中有很多不同的组件，每个组件需要相互通信，
	但又不能将自己内部数据过多地暴露给其他组件。用外观模式隔离数据是个很好的方法。
	6.策略模式在Java中的应用，这个太明显了，因为Comparator这个接口简直就是为策略模式而生的。
	Comparable和Comparator的区别一文中，详细讲了Comparator的使用。比方说Collections里面有一个sort方法，
	因为集合里面的元素有可能是复合对象，复合对象并不像基本数据类型，可以根据大小排序，复合对象怎么排序呢？
	基于这个问题考虑，Java要求如果定义的复合对象要有排序的功能，就自行实现Comparable接口或Comparator接口.
	7.原型模式：使用原型模式创建对象比直接new一个对象在性能上好得多，因为Object类的clone()方法是一个native方法，
	它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。
	8.迭代器模式：Iterable接口和Iterator接口 这两个都是迭代相关的接口，可以这么认为，实现了Iterable接口，
	则表示某个对象是可被迭代的；Iterator接口相当于是一个迭代器，实现了Iterator接口，
	等于具体定义了这个可被迭代的对象时如何进行迭代的	

面试题：
	Spring面试题
	1、spring在ssm中起什么作用？
	》spring：轻量级框架
	》作用：bean工厂，用来管理bean的生命周期和框架集成
	》两大核心：IOC/DI（控制反转/依赖注入）：把dao依赖注入到service层，service层反转给action层，spring顶层容器为BeanFactory
	》》AOP：面向切面编程
	
	2、Spring的事务？
	》编程式事务管理：编程方式管理事务，极大灵活性，难维护。
	》声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。
	
	3、IOC在项目中的作用？
	》作用：Ioc解决对象之间的依赖问题，把所有Bean的依赖关系通过配置文件或注解关联起来，降低了耦合度。
	
	4、Spring的配置文件中的内容？
	》开启事务注解驱动
	》事务管理器
	》开启注解功能，并配置扫描包。
	》配置数据库
	》配置SQL会话工厂，别名，映射文件
	》不用编写Dao层的实现类
	
	5、Spring下的注解？
	》注册：@Controller @Service @Component
	》注入：@Autowired @Resource
	》请求地址：@RequestMapping
	》返回具体数据类型而非跳转：@ResponseBody
	
	6、SpringDI的三种方式
	》构造器注入：通过构造方法初始化
	》》<constructor-arg index="0" type="java.lang.String" value="baoma" />
	》setter方法注入：通过setter方法初始化
	》》<property name="id" value="baoma" />
	》接口注入
	
	7、Spring主要使用了什么模式？
	》工厂模式：每个Bean的创建通过方法
	》单例模式：默认的每个Bean的作用域都是单例
	》代理模式：关于Aop的实现通过代理模式
	
	8、IOC/AOP的实现原理？
	》IOC：通过反射机制生成对象注入
	》AOP：动态代理