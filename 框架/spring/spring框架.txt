Spring AOP
	1、spring中配置的bean是在什么时候实例化的？
	》默认容器在加载的时候初始化bean，但是也可以通过设置lazy-init属性来延迟加载。
	
	2、描述一下spring中的ioc、aop和DI	
	》ioc和aop是spring的两大核心思想
	ioc（控制反转）：
	》利用反射的原理将对象创建的权利交给了spring容器，spring在运行的时候根据配置文件来动态的创建对象和维护对象
	》》之间的关系，实现了松耦合的思想；
	》应用：项目中的bean都可以交给spring容器来维护，这样bean的创建及销毁以及生命周期都由spring来处理；
	aop（面向切面编程）：
	》通过配置可以实现把业务逻辑和系统服务分离，业务逻辑只关心业务的处理而不再去处理其他事情；
	》应用：事务，日志，权限等。
	DI（依赖注入）：
	》由spring容器将对象注入到使用它的地方被注入的对象只提供对应的方法接收就行，由容器来决定对象之间的依赖关系
	》应用：例如service层需要调用dao层访问数据库，这时可以把dao层的bean给spring管理，我们只需要在service中定义
	》》对应的方法来接收spring管理的dao层bean
	
	4、spring如何配置声明式事务控制
	声明式事务管理有两种常用的方式：
	》基于tx和aop名字空间的xml配置文件
	》基于@Transaction注解
	配置方式：
	》配置事务管理器
	》事务的策略（这里可以配置事务的隔离级别，传播属性，是否可读等）
	》配置事务的切入点，注入事务属性
	注解方式：
	》配置事务管理器
	》开启事务控制的注解支持
	》在类或者方法上面添加@Transaction，事务的属性都在该注解的属性上设置
	
	5、spring的作用域有哪些
	》spring的作用域有singleton、prototype、request、session和global session和global session
	》singleton 默认配置，一个实例
	》prototype 每次调用都会创建一个新的实例
	》request   每一个HTTP请求都有自己的bean实例，仅在基于web的spring applicationContext中可用
	》session   每个HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP Session有效
	》global session 在一个全局的HttpSession中，容器会返回该bean的同一个实例，仅在使用portletContext时有效

	6、spring AOP的低层原理是什么？拦截器的优势有哪些？
	》spring AOP的低层是通过代理来实现的
	》一种是基于JDK的动态代理
	》一种是基于CgLIB的动态代理
	拦截器的优势有哪些？
	》拦截器是基于java反射机制实现的，使用代理模式
	》拦截器不依赖于servlet容器
	》拦截器只能对action请求起作用
	》拦截器可以访问action上下文
	》拦截器可以获取IOC容器中的各个bean
	》在action生命周期中，拦截器可以被多次调用
	
	7、如何手写代码实现spring原理
	》spring是个巨大的工厂，这个工厂就是专门用来生成bean，所以如果要手写那就一定要用到工厂设计模式
	》写一个工厂类，对外提供一个静态方法，这个方法接收用户要创建对象的一个id，对象和id可以写到配置文件
	》》里面，工厂再提供一个init方法进行读取配置文件
	》用户调用的是根据传入id在配置文件中找到要创建的对象，最后通过反射创建对象并返回给用户
	
	8、Controller接收JSON数据使用哪个注解？
	》接收方法使用@RequestBody注解，发送时contentType要设置为application/json
	
	9、springMVC的工作原理
	》用户向服务器发送请求，DispatcherServlet捕获该请求
	》DispatcherServlet对请求URL进行解析，得到URI
	》根据URI，调用HandlerMapping获取Handler配置的所有相关对象，最后以HandlerExeutionChain对象的形式返回
	》DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter，提取Request中的模型数据。
	》》填充Handler入参，开始执行Controller
	》Controller执行完成后，选择一个适合的ViewResolver将返回对象ModelAndView返回给DispatcherServlet
	》》ViewResolver结合Model和View，来渲染视图，并将渲染结果返回给客户端
	
	10、对ssm的理解，他们是如何协作完成功能开发的？
	》ssm是标准MVC设计模式，将整个系统划分为显示层，控制层，业务层，数据层四层。
	》SpringMVC负责请求的转发和视图管理
	》》MyBatis负责数据库查询数据库
	》》Spring则是负责协调，实现业务对象管理即：负责不同层面的衔接
	
	11、SpringMVC中的常用注解及其作用
	》@RequestMapping 请求和方法映射
	》@RequestBody    接收客户端传入的JSON数据
	》@ResponceBody   返回客户端JSON数据	
	》@Controller     标识控制层
	》@Service        标识业务层
	》@Repository     标识数据层
	》@Component      把bean添加到Spring容器中
	》@Autowired      按照类型自动注入
	》@Resource       自定义注入，可以按照类型注入 也可以按照名字注入
	》@PathVariable   RESTful风格时使用
	》@Param		  表单参数和方法形参不一样时使用	  

面试题：
	Spring面试题
	1、spring在ssm中起什么作用？
	》spring：轻量级框架
	》作用：bean工厂，用来管理bean的生命周期和框架集成
	》两大核心：IOC/DI（控制反转/依赖注入）：把dao依赖注入到service层，service层反转给action层，spring顶层容器为BeanFactory
	》》AOP：面向切面编程
	
	2、Spring的事务？
	》编程式事务管理：编程方式管理事务，极大灵活性，难维护。
	》声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。
	
	3、IOC在项目中的作用？
	》作用：Ioc解决对象之间的依赖问题，把所有Bean的依赖关系通过配置文件或注解关联起来，降低了耦合度。
	
	4、Spring的配置文件中的内容？
	》开启事务注解驱动
	》事务管理器
	》开启注解功能，并配置扫描包。
	》配置数据库
	》配置SQL会话工厂，别名，映射文件
	》不用编写Dao层的实现类
	
	5、Spring下的注解？
	》注册：@Controller @Service @Component
	》注入：@Autowired @Resource
	》请求地址：@RequestMapping
	》返回具体数据类型而非跳转：@ResponseBody
	
	6、SpringDI的三种方式
	》构造器注入：通过构造方法初始化
	》》<constructor-arg index="0" type="java.lang.String" value="baoma" />
	》setter方法注入：通过setter方法初始化
	》》<property name="id" value="baoma" />
	》接口注入
	
	7、Spring主要使用了什么模式？
	》工厂模式：每个Bean的创建通过方法
	》单例模式：默认的每个Bean的作用域都是单例
	》代理模式：关于Aop的实现通过代理模式
	
	8、IOC/AOP的实现原理？
	》IOC：通过反射机制生成对象注入
	》AOP：动态代理
	
SpringMVC面试题
		1、SpringMVC的控制器是不是单例模式，如果是；有什么问题，怎么解决？
		》问题： SpringMVC的控制器是不是单例模式，如果是，有什么问题，怎么解决？
		》解决：是单例模式，所以在多线程访问的时候有线程安全问题，不要用同步，会影响性能，
		》解决方案是在控制器里面不能写字段。
		
		2、SpringMVC中控制器的注解？
		》@Controller：该注解表明该类扮演控制器的角色
		
		3、@RequestMapping 注解用在类上的作用？
		》作用：用来映射一个URL到一个类或者一个特定的处理方法上
		
		4、前台多个参数，这些参数都是一个对象，快速得到对象？
		》方法：直接在方法中声明这个对象，SpringMVC就自动把属性赋值到这个对象里面
		
		5、SpringMVC中函数的返回值？
		》String、ModelAndView，List，Set等
		》一般String，Ajax请求，返回一个list集合
		
		6、SpringMVC中的转发和重定向？
		》转发：return : "hello"
		》重定向：return : "redirect:hello.jsp"
		
		7、SpringMVC和Ajax之间的相互调用？
		》通过JackSon框架把java里面对象直接转换成js可识别的json对象，具体步骤如下：
		》加入jackSon.jar
		》在配置文件中配置json的映射
		》在接收Ajax方法里面直接返回Object，list等，方法前面需要加上注解@ResonanceBody
		
		8、SpringMVC工作流程图？
		》图片见当前目录（springmvc工作流程.png）
		
		9、Struts2和SpringMVC的区别？
		》入口不同：
		》Struts2：filter过滤器
		》SpringMVC：一个Servlet即前端控制器
		》开发方式不同：
		》Struts2：基于类开发，传递参数通过类的属性，只能设置为多例
		》SpringMVC：基于方法开发（一个url对应一个方法），请求参数传递到方法形参，可以为单例也可以多例
		》请求方法不同：
		》Struts2：值栈存储请求和响应的数据，通过OGNL存取数据
		》SpringMVC：通过参数解析器将request请求内容解析，给方法形参复制，将数据和视图封装成ModelAndView对象，
		》》最后又将ModelAndView中的模型数据通过request域传输到页面，jsp视图解析器默认使用的是jstl。
		
MyBatis面试题
		1、Ibatis和Mybatis？
		》Ibatis：2010年，apache的Ibatis框架停止更新，并移交给了google团队，同时更名为MyBatis。
		》MyBatis：Ibatis的升级版本
		
		2、什么是Mybatis的接口绑定，有什么好处？
		》Mybatis实现了DAO接口与xml映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。
		
		3、什么情况注解，什么情况用xml绑定？
		》注解使用：SQL语句简单时
		》xml绑定使用情况：xml绑定（@RequestMap用来绑定xml文件）
		
		4、MyBatis的核心处理类叫什么
		》SqlSession
		
		5、查询表名和返回实体Bean对象不一致，如何处理？
		》映射键值对即可
		》<result column="title" property="title" javaType="java.lang.String" />
		》column：数据库中表的列名
		》property：实体Bean中的属性名
		
		6、MyBatis的好处？
		》把Sql语句从java中独立出来
		》封装了底层的JDBC，API的调用，并且能够将结果集自动转换成JavaBean对象，简化了java数据库编程的重复工作
		》自己编写Sql语句，更加的灵活
		》入参无需用对象封装，使用@param注解
		
		7、MyBatis配置一对多？
		》<collection property="topicComment" column="id" ofType="com.tmf.bbs.pojo.Comment" select="selectComment" />
		》property：属性名
		》column：共同列
		》ofType：集合中元素的类型
		》select：要连接的查询
		
		8、MyBatis配置一对一？
		》<association property="topicType" select="selectType" column="topics_type_id" javaType="com.tmf.bbs.pojo.Type" />
		》property：属性名
		》select：要连接的查询
		》column：共同列
		》javaType：集合中元素类型
		
		9、${} 和 #{}的区别？
		》${}：简单字符串替换，把${}直接替换成变量的值，不做任何转换，这种是取值以后再去编译SQL语句
		》#{}: 预编译处理，sql中的#{}替换成？补全预编译语句，有效的防止Sql语句注入，这种取值是编译好SQL语句再取值
		
		10、获取上一次自动生成的主键值？
		》select last _insert_id()
		
		11、MyBatis如何分页，分页原理？
		》RowBounds对象分页
		》在Sql内直接书写，带有物理分页
		
		12、MyBatis工作原理？
		》图片请看当前目录（MyBAtis工作原理.jpg）
		》原理：
		》通过SqlSessionFactoryBuilder从mybatis-Config.xml配置文件中构建出SqlSessionFactory。
		》SqlSessionFactory开启一个SqlSession，通过SqlSession实例获得Mapper对象并且运行Mapper映射的Sql语句
		》完成数据库的CRUD操作和事务提交，关闭SqlSession
		
		
		
   	