
 

 
――线性表――栈与队列――树与二叉树――图――查找算法――排序
 




 基本概念 
、数据元素是数据的基本单位。 
、数据项是数据不可分割的最小单位。 
、数据结构的 
逻辑结构（抽象的，与实现无关） 
物理结构（存储结构）  顺序映像（顺序存储结构）位置“相邻” 
       非顺序映像（链式存储结构）指针表示关系 
、算法特性：算法具有正确性、有穷性，确定性，（可行性）、输入，输出 
 
 
 
 
 
 
、算法设计的要求： 
1）正  确 性：算法应能满足设定的功能和要求 。 
  （2）可  读 性：思路清晰、层次分明、易读易懂 。 
  （3）健  壮 性：输入非法数据时应能作适当的反应和处理。 
  （4）高  效 性（时间复杂度）：解决问题时间越短，算法的效率就越高。   
  （5）低存储量（空间复杂度）：完成同一功能，占用存储空间应尽可能少。 
 线性表 
、
 List：最常用且最简单的数据结构。 
 
、
n个数据元素的有限序列。 
 ①“第一个” ②“最后一个” ③前驱 ④后继。 
、
――线性表的顺序存储结构 
 
逻辑上相邻的元素在物理位置上相邻。 
随机访问。 

 typedef struct{ 
 DataType elem[MAXSIZE]; 
 int length; 


 表长为n时，线性表进行插入和删除操作的时间复杂度为O（n）‘ 
 
n-1）\2 
、
 
 类型定义 
“数据 + 指针”。 
 struct LNode { 
       DataType data; 
       struct LNode *next; 

 不带头结点的空表判定为 L= =null 
  L->next= =null 
 L.next= =L 
NULL 
 
、顺序表和单链表的比较              0 1 MAXSIZE-1 ... L.elem[] L.elem[] L.elem[] L.length==0 L.length==MAXSIZE 0<L.length<MAXSIZE data next 
 单链表 
 用指针表示关系 
O(1) 顺序访问，取元素O(n) 
O(n) 插入、删除不用移动元素O(n)(用于查找位
) 
、
 
         缺点：大小固定；不利于增减节点;存储空间不能充分利用；容量
 

 
    缺点：增加了存储空间的开销；不可以随机存储元素 
 栈与队列 
、栈 
 
 
 
 
 
、栈分为链栈和顺序栈 
・链栈 
 
・顺序栈 
 a1 /\ an  S ... an-1  
:进栈运算是在栈顶位置插入一个新元素x。

a)判栈是否为满，若栈满，作溢出处理，并返回0；
b)若栈未满，栈顶指针top加1；
c)将新元素x送入栈顶，并返回1。

Push (SeqStack*s，datatypex)
（s->top= =MAXLENC1）
；// 栈满不能入栈，且返回0
；
；// 栈不满，则压入元素x
；}                // 进栈成功，返回1
出栈:出栈运算是指取出栈顶元素，赋给某一个指定变量x。算法步骤：(a)判栈是否为空，若栈空，作下溢处理，并返回0；(b)  若栈非空，将栈顶元素赋给变量x；(c)指针top减1，并返回1。算法实现：datatypePop（SeqStack*s）{    datatypex;if  (SEmpty( s ) ) return 0；// 若栈空不能出栈，且返回0
；
栈不空则栈顶元素存入*x
-；
；}       // 出栈成功，返回1


、队列 
 
 对头出队 
 
 

、链队列 
typedefstructqueuenode{datatypedata;  structqueuenode*next;}queuenode;       // 链队结点的类型datatypetypedefstruct{queuenode*front,*rear;}linkqueue;      // 将头指针、尾指针封装在一起的链队frontrearpABJ^…图4-6    链队列示意图 


、 循环队列

 struct { 
   DataType elem[MAXSIZE]; 
   int front, rear;   // 队头、队尾位置 


 front=rear 
 （rear+1）%m=front 
 
、栈与队列比较：
LIFO（后进先出），队列操
FIFO（先进先出）。 
 树和二叉树 

 树的定义 
树（Tree）：是 n（n≥0）个有限数据元素的集合。 
在任意一棵非空树T中： 
（1）有且仅有一个特定的称为树根（Root）的结点，根结点无前趋结点； 
（2）当n>1时，除根结点之外的其余结点被分成m(m>0)个互不相交的集
T1，T2，?，Tm，其中每一个集合Ti（1≤ i ≤m）本身又是一棵树，并且称
 
 基本术语： 
 

 
0，其余结点的层数等于其父结点的层数加1 
 
 
 
 

 二叉树性质： 
 二叉树的第i层上至多有2i-1个结点。 
 深度为k的二叉树至多有2k-1个结点。 
     满二叉树：深度为k，有2k-1个结点。 
：给满二叉树的结点编号，从上至下，从左至右，n个结点的完全二
1到n。 
 叶子结点n
，度为2的结点为n2，则n0 = n2+1。 
n = n
 + n1 + n2 
n-1 = 2n
 + n1 
n
= n2+1 
 n个结点的完全二叉树深度为1logn。 
 n个结点的完全二叉树，结点按层次编号 
  i的双亲是2/n，如果i = 1时为根（无双亲）； 
     i的左孩子是2i，如果2i>n，则无左孩子； 
     i的右孩子是2i + 1，如果2i + 1>n则无右孩子。 
 二叉树的存储结构 
 
i的结点存放在[i-1]处。适合于存储完全二叉树。 
 
 
 struct BTNode { 
 DataType data; 
 struct BTNode *lchild, *rchild; 

 
 struct BTNode { 
 DataType data; 
 struct BTNode *lchild, *rchild, *parent; 





n个结点的二叉链表有n+1个空链域。 

 遍历二叉树（先序DLR、中序LDR、后序LRD）方法与C语言描述 
D）、根结点的左子树（L）和根结点的右
R）三部分组成。因此，只要依次遍历这三部分，就可以遍历整个二叉树。一般有三
先序(前序)遍历DLR（根左右）、中序遍历LDR（左根右）、 后序遍历LRD（左右根）。 data parent lchild rchild data rchild lchild 
．先序遍历（DLR）的递归过程
reorder(BT*T)      // 先序遍历二叉树BT
// 递归调用的结束条件
// 输出结点的数据域
// 先序递归遍历左子树
// 先序递归遍历右子树


．中序遍历（LDR）的递归过程
*T)// 中序遍历二叉树BT
// 递归调用的结束条件
//  中序递归遍历左子树
// 输出结点的数据域
// 中序递归遍历右子树

3．后序遍历（LRD）的递归过程
*T)                    // 后序遍历二叉树BT
// 递归调用的结束条件
// 后序递归遍历左子树
// 后序递归遍历右子树
// 输出结点的数据域




 线索二叉树 
个结点的二叉链表中有n+1个空指针，可以利用其指向前驱或后继结点，叫线索，同
 
 
有左子树，则指向左子树，标志ltag == 0； 
没有左子树，可作为前驱线索，标志ltag == 1。 
有右子树，则指向右子树，标志rtag == 0； 
没有右子树，可作为后继线索，标志rtag == 1。 

 树和森林 

 
，孩子表示法，孩子兄弟表示法。 
双亲表示法容易求得双亲，但不容易求得孩子；孩子表示法容易求得孩子，
两者可以结合起来使用。孩子兄弟表示法，容易求得孩子和兄弟，
 

lchild ltag data rtag rchild 0/1 0/1 
 
 错误！文档中没有指定样式的文字。.1 树和二叉树的对应关系 
 对应的二叉树 
 根 
 左孩子 
 右孩子 
 
 
ABCDEFGHIJK。 
CEDFBHGJKIA。 
 
 其余树(除第一棵外)组成
 
ABCDEFGHIJ。 
BDCEAGFIJH。 
先序遍历森林，相当于依次先根遍历每一棵树；中根遍历森林相当于后根遍历每一棵树。 

 
 
 森林 二叉树 
 先序遍历 先序遍历 
 中序遍历 中序遍历 

 哈夫曼树：叶子结点带有权值的最小带权路径长度的最优二叉树 

 
每次取两个最小的树组成二叉树 A B I C D F H G J K E A H B C E G F I J D ① ① ② ② ③ 树的结构划森林的结构划分 
(前缀码) 
0，向右分支为1，从根到叶子的路径构成叶子的前缀编码。 


 图 
． 
1\2 n(n-1)条变得无向图 
n（n-1）条弧的有向图。 
 
v的度：和v相关联的边的数目。 
v为头的弧的数目 
v为尾的弧的数目 
 
 
图的存储结构 
 

 
 struct ArcNode {  // 弧结点 
 int  adjvex; // 邻接点 
 struct ArcNode *nextarc; // 下一个邻接点 


 struct VexNode {  // 顶点结点 
 VertexType  data; // 顶点信息 
 ArcNode *firstarc; // 第一个邻接点 


 int MAX_VERTEX = 最大顶点个数; 
 struct Graph {  // 图 
 VexNode  vexs[MAX_VERTEX]; // 顶点向量 
 int  vexnum, arcnum; // 顶点和弧的个数 


(弧)多则需要存储空间多。 0 1 1 0 0 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0 1 0 0 1 0 A B C D E 
 
 

在十字链表中，对应于有向图中每一条弧有一个结
 
 
图的遍历 
 深度优先（DFS）搜索 
v出发：  
）访问顶点v； 
）从v的未被访问的邻接点出发，继续对图进行深度优先遍历，若从某点

 
 广度（宽度，BFS）优先搜索 
）访问顶点v ； 
）访问同v相邻的所有未被访问的邻接点w
,w2, …wk； 
）依次从这些邻接点出发，访问它们的所有未被访问的邻接点; 依此类推，
 
生成树和最小生成树 
每次遍历一个连通图将图的边分成遍历所经过的边和没有经过的边两部分，
该子图称为生成树。因此有DFS生成
BFS生成树。 
 最小生成树 
Kruskal算法 
“不构成环的情况下，每次选取最小边”。 


普里姆算法 A  B  C  D  E  1  2 /\ 0 1 2 3 4 2  3 /\ 3 /\ 0 /\ 0  3 /\ A B C D E 2 5 3 3 1 7 6 3 A B C D E 2 5 3 3 1 7 6 3 A B C D E 2 5 3 3 1 7 6 3 (a) (b) (c) A B C D E 2 5 3 3 1 7 6 3 A B C D E 2 5 3 3 1 7 6 3 A B C D E 2 5 3 3 1 7 6 3 (d) (e) (f) 
V是连通网的顶点集，U是求得生成树的顶点集，TE是求得生成树的边集。 
 
开始时，U={v
}，TE=Φ； 
计算U到其余顶点V-U的最小代价，将该顶点纳入U，边纳入TE； 
重复(b)直到U=V。 
 
 普里姆算法 克鲁斯卡尔算法 
间复杂
 O(n2) O(e loge) 
 只与顶点个数n有关 
e无关 
 只与边的数目e有关 与顶点个数n无关 适用于稀疏图 
 AOV-网  
AOV网。  
AOV网络中顶点构造拓扑有序序列的过程。 
 
在有向图中选一个没有前驱的顶点且输出之 
从图中删除该顶点和所有以它为尾的弧 

 关键路径 
网，关键路径 
网(Activity On Edge)――带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活
 
  

最短路径 
迪杰斯特拉算法 
 
(a) 初始化：用起点v到该顶点w的直接边(弧)初始化最短路径，否则设为∞； 
从未求得最短路径的终点中选择路径长度最小的终点u：即求得v到u的最短路径； 
修改最短路径：计算u的邻接点的最短路径，若(v,…,u)+(u,w)<(v,…,w)，则以(v,…,u,w)
 
重复(b)-(c)，直到求得v到其余所有顶点的最短路径。 
 

弗洛伊德算法 
 
A(0)，A(1)，…，A(n)。A(0)为邻接矩阵，计算A(k)时，A(k)(i,j)=min{A(k-1)(i,j), A(k-1)(i,k)+A(k-1)(k,j)}。 
A(k)的技巧。第k行、第k列、对角线的元素保持不变，对其余元素，考查A(i,j)
A(i,k)+A(k,j) （“行+列”），如果后者更小则替换A(i,j)，同时修改路径。 


 查找 
 查找分为：静态查找表、动态查找表、哈希查找表 
 静态查找表：对查找表只作查找操作的查找表。 

 
 顺序查找：顺序查找又称线性查找，是最基本的查找方法之一。顺序查找既
 
 二分法（折半）查找：是一种效率较高的查找方法，但前提是表中元素必须
 
 索引顺序表查找又称分块查找。分块查找：块内无序、块间有序、如何分块
 
 动态查找表：二叉排序树查找：二叉排序树的生成  
(二叉查找树)：或者是一颗空树。或者如下1若它的左子树不空，
2若右子树不空，则右
3 左右子树也分别为二叉排序
 
 哈希表：哈希函数构造：直接定址法、除留余数法、平方取中法，随机数法，          
 
 
 排序 
插入类排序： 
 

 
 
 

 基本有序 时在对全体序列进行一次直

 
交换类排序 
 
每相邻两个记录关键字比大小,大的记录往下沉（也可以小
。每一遍把最后一个下沉的位置记下，下一遍只需检查比较到

。 
 
R[1..H]中任取一个数据元素作为比较的"基准"(不妨记为X)，用此基
R[1..I-1]和R[I+1..H]，且左边的无
右边的无序子区中数据元素均大于等于基
而基准X则位于最终排序的位置上，即R[1..I-1]≤X.Key≤R[I+1..H](1≤I≤H)，
R[1..I-1]和R[I+1..H]均非空时，分别对它们进行上述的划分过程，直至所有无序
 
选择类排序 
 
（或最大）的一个元素，顺序放在已排好序
 
 
R[1..N]看成是一颗完全二叉树的顺序

 
归并类排序 
 
基数类排序 
 
 
 
MSD法）从主关键字开始排序，再从次高位排序，一次类推，
 
LSD法）从最次位关键字开始排序，在对高一位的进行排序，
 

 稳定性 平均时间 最坏情况 辅助存储 
 稳定 O（n*n） O（n*n） O（1） 
 不稳定 O（nlbn） O（n*n） O（lbn） 
 稳定 O(nlbn) O（nlbn） O（n） 
 稳定 O（n*n） O（n*n） O（1） 
 不稳定 O（nlbn） O（nlbn） O(1) 
 稳定 O（d（n+rd）） O（d（n+rd）） O（rd） 
选取排序方法需要考虑的因素： 
待排序的元素数目n； 
元素本身信息量的大小； 
关键字的结构及其分布情况； 
语言工具的条件，辅助空间的大小等。 
小结： 
若n较小(n <= 50)，则可以采用直接插入排序或直接选择排序。由

 
若文件的初始状态已按关键字基本有序，则选用直接插入或冒泡排
 
若n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、
 
 
在基于比较排序方法中，每次比较两个关键字的大小之后，仅仅出

n个关键字随机分布时，任何借助于"比较"的排序
O(nlog2n)的时间。

